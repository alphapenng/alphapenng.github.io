<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:webfeeds="http://webfeeds.org/rss/1.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>寂寞留白</title><link>https://alphapenng.github.io/zh-cn/</link><description>Recent content on 寂寞留白</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 03 Aug 2022 09:56:33 +0800</lastBuildDate><atom:link href="https://alphapenng.github.io/zh-cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Git学习笔记</title><link>https://alphapenng.github.io/zh-cn/2022/08/03/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><pubDate>Wed, 03 Aug 2022 09:56:33 +0800</pubDate><guid>https://alphapenng.github.io/zh-cn/2022/08/03/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><description>Git 基本原理介绍 参考来自 Git 基本原理介绍 | Escape 学习 笔记 参考来自 我的 Git 学习笔记 | Escape 编号 专用名词 对应解释 相关命令 1 Workspace 工作区 add 2 Index/Stage 暂存区 commit 3 Repository 本地仓库 p</description><content:encoded><![CDATA[<h2 id="git-基本原理介绍">Git 基本原理介绍</h2>
<blockquote>
<p>参考来自 <a href="https://www.escapelife.site/posts/da89563c.html">Git 基本原理介绍 | Escape</a></p>
</blockquote>
<h2 id="学习-笔记">学习 笔记</h2>
<blockquote>
<p>参考来自 <a href="https://www.escapelife.site/posts/8f4661c4.html">我的 Git 学习笔记 | Escape</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>编号</th>
<th>专用名词</th>
<th style="text-align:left">对应解释</th>
<th style="text-align:left">相关命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Workspace</td>
<td style="text-align:left">工作区</td>
<td style="text-align:left">add</td>
</tr>
<tr>
<td>2</td>
<td>Index/Stage</td>
<td style="text-align:left">暂存区</td>
<td style="text-align:left">commit</td>
</tr>
<tr>
<td>3</td>
<td>Repository</td>
<td style="text-align:left">本地仓库</td>
<td style="text-align:left">push、checkout</td>
</tr>
<tr>
<td>4</td>
<td>Remote</td>
<td style="text-align:left">远程仓库</td>
<td style="text-align:left">fetch、clone、pull</td>
</tr>
</tbody>
</table>
<p><img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_09_12_%E6%88%91%E7%9A%84Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.png" alt="文件的生命周期状态"></p>
<p><img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_09_12_%E6%88%91%E7%9A%84Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02.png" alt="文件的生命周期状态"></p>
<ol>
<li>Git 增删改查</li>
</ol>
<blockquote>
<p>参考来自 <a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></p>
</blockquote>
<pre tabindex="0"><code>$ cd learngit
$ git init  # 初始化Git仓库
** create readme.txt
** echo &#34;line 1 &#34;&gt;&gt; readme.txt

$ git add readme.txt            # 添加到暂存空间
$ git commit -m &#34;first commit&#34;  # 提交加备注信息
** echo &#34;error line 2&#34; &gt;&gt; readme.txt

$ git add readme.txt
$ git status  # 查看状态
** have a change.

$ git reset HEAD readme.txt  # 将暂存空间内容撤销
$ git checkout readme.txt    # 撤销工作空间内容
** echo &#34;line2&#34; &gt;&gt; readme.txt
$ git add readme.txt
$ git commit -m &#34;commit line 2 &#34;

$ git reset --hard HEAD^    # 回退为上个版本(删除修改)
$ git reset --hard (gitID)  # 回退为指定版本(删除修改)
$ git reset --soft (gitID)  # 回退为指定版本(不删除回退文件的修改)
$ git log                   # 查看当前版本及之前版本的id号
</code></pre><blockquote>
<p>参考来自 <a href="https://oschina.gitee.io/learn-git-branching/">learn-git-branching</a></p>
</blockquote>
<pre tabindex="0"><code># Git 仓库创建
$ git init                 # 将当前目录设为Git代码库
$ git init [project-name]  # 新建并将其设为Git代码库
$ git clone [url]          # 通过连接下载一个已有项目

# Git增加文件
$ git add [file1] [file2]  # 添加指定文件到暂存区
$ git add [dir]            # 添加指定目录到暂存区
$ git add .                # 添加当前所有文件到暂存区
$ git add -p               # 添加每个变化前都要求确认

# Git删除文件
$ git rm [file1] [file2]  # 删除工作区文件并且将这次删除放入暂存区
$ git rm --cached [file]  # 停止追踪指定文件但该文件会保留在工作区
$ git mv [file-original] [file-renamed]

# Git代码提交
$ git commit -m [message]             # 提交暂存区到仓库区
$ git commit -a                       # 提交工作区自上次commit之后的变化直接到仓库区
$ git commit -v                       # 提交时显示所有diff信息
$ git commit --amend -m [message]     # 使用一次新的commit替代上一次提交
$ git commit --amend [file1] [file2]  # 重做上一次commit并包括指定文件的新变化

# Git撤销操作
$ git checkout .                # 恢复暂存区的所有文件到工作区
$ git checkout [file]           # 恢复暂存区的指定文件到工作区
$ git checkout [commit] [file]  # 恢复某个commit的指定文件到暂存区和工作区

# Git重置操作
$ git reset [file]           # 重置暂存区的指定文件；与上一次commit保持一致但工作区不变
$ git reset --hard           # 重置暂存区与工作区文件；与上一次commit保持一致；谨慎使用
$ git reset [commit]         # 重置当前分支的指针为指定commit；同时重置暂存区但工作区不变
$ git reset --hard [commit]  # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区
$ git reset --keep [commit]  # 重置当前HEAD为指定commit，但保持暂存区和工作区不变

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消并且应用到当前分支
$ git revert [commit]
</code></pre><ol start="2">
<li>Git 远程仓库</li>
</ol>
<blockquote>
<p>参考来自 <a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></p>
</blockquote>
<pre tabindex="0"><code># 注册github.com并创建本机的ssh-key
$ ssh-keygen -t rsa -C &#34;123456789@qq.com&#34;

# 添加ssh-key到秘钥管理里面并关联远程仓库
$ git remote add origin git@github.com:xxx/learngit.git

# 如果远程仓库已经存在内容需要先pull下面，之后再提交
$ git pull origin master

# 将本地库push到远程仓库，第一次需要加u关联，之后可以不加
$ git push -u origin master

# 仓库克隆
$ git clone git@github.com:xxx/gitkills.git
</code></pre><blockquote>
<p>参考来自 <a href="https://oschina.gitee.io/learn-git-branching/">learn-git-branching</a></p>
</blockquote>
<pre tabindex="0"><code># Git远程分支推送
$ git fetch [remote]          # 下载远程仓库的所有变动
$ git pull [remote] [branch]  # 取回远程仓库的变化，并与本地分支合并
$ git push [remote] [branch]  # 上传本地指定分支到远程仓库
$ git push [remote] --force   # 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --all     # 推送所有分支到远程仓库

# Git远程同分支查看
$ git remote -v                     # 显示所有远程仓库
$ git remote show [remote]          # 显示某个远程仓库的信息
$ git remote add [shortname] [url]  # 增加一个新的远程仓库并命名
</code></pre><ol start="3">
<li>Git 分支管理</li>
</ol>
<blockquote>
<p>参考来自 <a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></p>
</blockquote>
<ul>
<li>在工作区未提交的内容，所有分支都可以看到</li>
<li>提交之后的内容在对应的分支内，切换只能在对应的分支内看到</li>
</ul>
<pre tabindex="0"><code># 查看分支列表，其中*为当前分支
git branch

# 创建分支
git branch &lt;name&gt;

# 切换分支
git checkout &lt;name&gt;

# 创建并切换分支
git checkout -b &lt;name&gt;

# 合并某分支到当前分支
git merge &lt;name&gt;

# 删除分支
git branch -d &lt;name&gt;

# 强行删除分支
git branch -D &lt;name&gt;
</code></pre><blockquote>
<p>参考来自 <a href="https://oschina.gitee.io/learn-git-branching/">learn-git-branching</a></p>
</blockquote>
<pre tabindex="0"><code># Git查看分支
$ git branch     # 列出所有本地分支
$ git branch -r  # 列出所有远程分支
$ git branch -a  # 列出所有本地分支和远程分支

# Git分支切换
$ git branch [branch-name]     # 新建一个分支但停留在当前分支
$ git checkout -b [branch]     # 新建一个分支并切换到该分支
$ git checkout [branch-name]   # 切换到指定分支并更新工作区
$ git checkout -               # 切换到上一个分支
$ git branch -d [branch-name]  # 删除分支

# Git分支删除
$ git push origin --delete [branch-name]  # 删除远程分支
$ git branch -dr [remote/branch]          # 删除远程分支

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]
</code></pre><ol start="4">
<li>Git 冲突处理</li>
</ol>
<blockquote>
<p>参考来自 <a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></p>
</blockquote>
<ul>
<li>合并时显示分支冲突先 <code>merge</code> 后修改 <code>&lt;&lt;&lt;&lt;分支1</code>、<code>&lt;&lt;&lt;分支2</code> 之间的冲突内容，然后再提交。当前分支会比被合并的分支，多一次 commit 的提交记录。</li>
</ul>
<pre tabindex="0"><code># 合并指定分支到当前分支
# 禁用Fast forward功能，不删除分支且合并后保留分支
git merge --no-ff [branch]

# 选择一个commit并合并进当前分支
$ git cherry-pick [commit]
</code></pre><ol start="5">
<li>Git 比对日志</li>
</ol>
<blockquote>
<p>参考来自 <a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></p>
</blockquote>
<pre tabindex="0"><code># 查看分支情况
git log --graph --pretty=oneline --abbrev-commit
git log --graph --decorate --pretty=oneline --abbrev-commit --all
git log --pretty=fsormat:&#39;%s %C(bold blue)(%an)%Creset&#39; --abbrev-commit
git log --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit
</code></pre><blockquote>
<p>参考来自 <a href="https://oschina.gitee.io/learn-git-branching/">learn-git-branching</a></p>
</blockquote>
<pre tabindex="0"><code># Git日志格式

$ git log                        # 显示当前分支的版本历史
$ git log --stat                 # 显示commit历史及每次commit变更的文件
$ git log -5 --pretty --oneline  # 显示过去5次提交
$ git reflog                     # 显示当前分支的最近几次提交
$ git shortlog -sn               # 显示所有提交过的用户，按提交次数排序

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&#34;提交说明&#34;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# Git高级查询
$ git blame [file]                     # 显示指定文件是什么人在什么时间修改过
$ git log -p [file]                    # 显示指定文件相关的每一次diff
$ git log -S [keyword]                 # 根据关键词搜索提交历史
$ git diff --shortstat &#34;@{0 day ago}&#34;  # 显示今天你写了多少行代码

# Git 差异对比
$ git diff  # 显示暂存区和工作区的差异
$ git diff --cached [file]  # 显示暂存区和上一个commit的差异
$ git diff HEAD  # 显示工作区与当前分支最新commit之间的差异
$ git diff [first-branch]...[second-branch]  # 显示两次提交之间的差异

# Git显示内容
$ git show [commit]              # 显示某次提交的元数据和内容变化
$ git show --name-only [commit]  # 显示某次提交发生变化的文件
$ git show [commit]:[filename]   # 显示某次提交时某个文件的内容
</code></pre><ol start="6">
<li>Git 内容存储</li>
</ol>
<blockquote>
<p>参考来自 <a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></p>
</blockquote>
<ul>
<li>正在 dev 分支工作时，需要修改 bug 并提交。应该先把 dev 当前工作区 stash 储藏起来，修改完 bug 提交后在使用 git stash pop 恢复 dev 的内容到工作区。</li>
</ul>
<pre tabindex="0"><code># 储藏当前工作区
git stash

# 查看储藏区
git stash list

# 恢复指定内容到工作区，不在stash内删除
# 其中的stashid可以通过git stash list查询
git stash apply &lt;stashid&gt;

# 删除储藏区
git stash drop &lt;stashid&gt;

# 恢复stash的内容到工作区，并在stash内删除
git stash pop
</code></pre><ol start="7">
<li>Git 标签管理</li>
</ol>
<blockquote>
<p>参考来自 <a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></p>
</blockquote>
<ul>
<li>标签基本都是发布版本的时候使用的，所以平常很少使用，了解即可。</li>
</ul>
<pre tabindex="0"><code># 新建标签，默认为在HEAD上，也可以指定一个commit id号
git tag &lt;name&gt;

# 指定标签信息
git tag -a &lt;tagname&gt; -m &#34;blablablabla&#34;

# 使用PGP签名标签
git tag -s &lt;tagname&gt; -m &#34;blablablabla&#34;

# 查看所有标签
git tag

# 查看指定tag的详细内容
git show &lt;tagname&gt;

# 删除tag标签
git tag -d &lt;tagname&gt;

# 推送指定标签到远程
git push origin &lt;tagname&gt;

# 推送所有标签到远程
git push origin --tags

# 从远程删除标签
git push origin :refs/tags/&lt;tagname&gt;
</code></pre><ol start="8">
<li>Git 配置管理</li>
</ol>
<blockquote>
<p>参考来自 <a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></p>
</blockquote>
<ul>
<li>主要配置日常使用工具和提交记录相关的配置，需要注意的是，区分全局和本地配置。</li>
</ul>
<pre tabindex="0"><code># 列出配置项
$ git config --list
$ git config --global --list

# 获取配置项
$ git config user.name &#34;escape&#34;
$ git config --global user.name &#34;escape&#34;
$ git config user.email &#34;escapelife@gmail.com&#34;
$ git config --global user.email &#34;escapelife@gmail.com&#34;

# 添加配置项
$ git config -–add site.name yiibai
$ git config --global -–add site.name yiibai

# 删除配置项
$ git config -–unset site.name
$ git config --global -–unset site.name

# 获取帮助
$ git help &lt;verb&gt;
$ git help config

# 配置全局默认编辑器
$ git config --global core.editor vim
$ git config --global core.editor emacs

# 配置比较工具
$ git config --global merge.tool vimdiff

# 全局代理配置
$ git config --global https.proxy http://127.0.0.1:1080
$ git config --global https.proxy https://127.0.0.1:1080

# 全局取消代理配置
$ git config --global --unset http.proxy
$ git config --global --unset https.proxy
</code></pre><ol start="9">
<li>Git  其他操作</li>
</ol>
<blockquote>
<p>参考来自 <a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></p>
</blockquote>
<pre tabindex="0"><code># 生成发布压缩包
$ git archive
</code></pre><ol start="10">
<li>快捷键总结</li>
</ol>
<blockquote>
<p>OpenSource：总结的快捷键使用文档！</p>
</blockquote>
<p><img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_09_12_GitCheatSheet.png" alt="Git Cheat Sheet"></p>
<h2 id="git-常用命令实战">Git 常用命令实战</h2>
<blockquote>
<p>参考来自 <a href="https://01.ftqq.com/2021/08/21/git-course/">Git 基础课</a></p>
</blockquote>
<ol>
<li><code>gitjk</code></li>
<li>使用 git 初始化命令
<code>git init</code></li>
<li>新建一个文件，把它添加到 git 里边
<code>echo &quot;make git great&quot; &gt; a.txt &amp;&amp; git add a.txt</code></li>
<li>将文件移除暂存区
<code>git reset HEAD -- a.txt</code></li>
<li>查看 git 仓库
<code>cd .git &amp;&amp; ls -la</code>
<code>cd objects &amp;&amp; ls -la</code></li>
<li>通过 git cat-file 命令查看文件内容
<code>git cat-file -p 61ac375fc5565c8a763d942dc599fd34128bdb37</code></li>
<li>查看 index 暂存区
<code>cd ../ &amp;&amp; git ls-files --stage</code></li>
<li>查看 HEAD 文件
<code>cat HEAD</code>
提示：引用文件不存在，因为还没有 commit</li>
<li>通过 commit 命令提交内容
<code>git commit -m 'first version'</code>
提示：回过头来看 HEAD 的引用</li>
<li>通过 git status 查看本地文件修改和暂存区的情况
<code>git status</code></li>
<li>修改 b.txt
<code>echo &quot;b&quot; &gt; b.txt</code></li>
<li>创建新分支
<code>git branch name</code></li>
<li>切换到某分支
<code>git checkout branch</code>
<code>git branch dev &amp;&amp; git checkout dev</code></li>
<li>编辑 a.txt 添加 make dev great again</li>
<li>将 a.txt 通过 add 加入暂存区，再通过 commit 放入仓库
<code>git add a.txt &amp;&amp; git commit -m 'dev'</code></li>
<li>checkout 回 master，再创建一个 ops 分支
<code>git checkout master &amp;&amp; git branch ops &amp;&amp; git checkout ops</code></li>
<li>编辑 a.txt，添加 make ops great again
<code>git add a.txt &amp;&amp; git commit -m 'ops'</code></li>
<li>开始合并分支 git merge</li>
<li>checkout 回 master，然后运行 merge 命令
<code>git checkout master &amp;&amp; git merge dev</code></li>
<li>带冲突的分支合并</li>
<li>checkout 回 dev
<code>git checkout dev</code></li>
<li>修改 a.txt
将 make dev great again 从第一行换到最后一行</li>
<li>提交修改
<code>git add a.txt &amp;&amp; git commit -m 'update a.txt'</code></li>
<li>再次合并
<code>git checkout master &amp;&amp; git merge dev &amp;&amp; git merge ops</code></li>
<li>合并失败后
<ul>
<li>放弃合并
<code>git merge --abort</code></li>
<li>手工合并冲突
打开 a.txt</li>
<li>再次提交
<code>git add a.txt &amp;&amp; git commit -m 'merged'</code></li>
</ul>
</li>
<li>通过 git log 查看日志
<code>git log</code></li>
<li>通过 checkout sha1，可以回到历史
<code>checkout -b 可以创建一个全新的分支</code></li>
<li>远程仓库
<ul>
<li>gitlab 创建仓库</li>
<li>git clone / git remote add</li>
<li>git push</li>
<li>再改用 github</li>
<li>git remote</li>
<li>git remote show <name></li>
<li>git remote remove <name></li>
<li>git remote add origin url</li>
<li>git push</li>
</ul>
</li>
<li>储藏区
<ul>
<li>往 a.txt 写入字符串
<code>echo &quot;Good&quot; &gt; a.txt &amp;&amp; git add a.txt &amp;&amp; git commit -m 'init2'</code>
<code>git stash</code>
<code>git stash apply</code>
<code>git stash list</code>
<code>git stash list</code>
<code>git stash show / drop / clear</code></li>
</ul>
</li>
</ol>
]]></content:encoded></item><item><title>Everything You Need to Know About Virtualization VMs Containers Pods Clusters</title><link>https://alphapenng.github.io/zh-cn/2022/08/02/everything-you-need-to-know-about-virtualization-vms-containers-pods-clusters/</link><pubDate>Tue, 02 Aug 2022 22:40:50 +0800</pubDate><guid>https://alphapenng.github.io/zh-cn/2022/08/02/everything-you-need-to-know-about-virtualization-vms-containers-pods-clusters/</guid><description>What is Virtualization? Virtualization is the act of dividing shared computational resources: CPU, RAM, Disk, and Networking into isolated resources that are unaware of the original shared scope. 虚拟化是将共享计算资源：CPU、RAM、磁盘和网络划分为不知道原始共享范围的孤立资源</description><content:encoded><![CDATA[<h2 id="what-is-virtualization">What is Virtualization?</h2>
<blockquote>
<p>Virtualization is the act of dividing shared computational resources: CPU, RAM, Disk, and Networking into isolated resources that are unaware of the original shared scope.</p>
</blockquote>
<p>虚拟化是将共享计算资源：CPU、RAM、磁盘和网络划分为不知道原始共享范围的孤立资源的行为。</p>
<p><img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_11_02_GqUqLA.jpg" alt="Virtualization"></p>
<h2 id="what-is-a-virtual-machine">What is a virtual machine?</h2>
<blockquote>
<p>A VM is a virtual env that functions as a virtual computer system with its own CPU, memory, nw  interface, &amp; storage, created on a physical hw system (located off- or on-prem).
It uses sw instead of a physical computer to run programs &amp; deploy apps.</p>
</blockquote>
<p>VM 是一个虚拟环境，它作为一个虚拟计算机系统运行，具有自己的 CPU、内存、nw 接口和存储，在物理硬件系统（位于外部或内部）上创建。
它使用 sw 而不是物理计算机来运行程序和部署应用程序。</p>
<p><img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_11_02_BLuYDw.jpg" alt="VM"></p>
<blockquote>
<p>The hypervisor allows multiple VMs to run on a single machine. Each VM includes a full copy of an operating system, the application, necessary binaries and libraries - taking up tens of GBs. VMs can also be slow to boot.</p>
</blockquote>
<p>管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本 - 占用数十 GB。 VM 的启动速度也可能很慢。</p>
<p><img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_11_02_UUusKw.jpg" alt="Hypervisor"></p>
<h2 id="what-is-a-hypervisor">What is a hypervisor?</h2>
<blockquote>
<p>A hypervisor is software that creates &amp; runs virtual machines (VMs). A hypervisor, sometimes called a virtual machine monitor (VMM), isolates the hypervisor operating system &amp; resources from the virtual machines &amp; enables the creation &amp;  mgmt of those VMs.</p>
</blockquote>
<p>管理程序是创建和运行虚拟机 (VM) 的软件。管理程序，有时称为虚拟机监视器 (VMM)，将管理程序操作系统和资源与虚拟机隔离，并支持创建和管理这些 VM。</p>
<p><img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_11_02_sNIk27.jpg" alt="hypervisor"></p>
<h3 id="types-of-hypervisors">Types of hypervisors</h3>
<blockquote>
<p>There are 2 different types of hypervisors that can be used for virtualization.</p>
</blockquote>
<p>有两种不同类型的管理程序可用于虚拟化。</p>
<ol>
<li>
<p>Type 1 - A type 1 hypervisor is on bare metal. VM resources are scheduled directly to the hardware by the hypervisor. KVM is an example of a type 1 hypervisor.
类型 1 - 1 类虚拟机管理程序位于裸机上。 VM 资源由管理程序直接调度到硬件。 KVM 是类型 1 管理程序的一个示例。
<img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_11_11_Xmnoy1.jpg" alt="Type 1 Hypervisor"></p>
</li>
<li>
<p>Type 2 - A type 2 hypervisor is hosted. VM resources are scheduled against a host operating system, which is then executed against the hardware. VMware Workstation and Oracle VirtualBox are examples of type 2 hypervisors.
类型 2 - 类型 2 管理程序是托管型。 VM 资源针对主机操作系统进行调度，然后针对硬件执行。 VMware Workstation 和 Oracle VirtualBox 是类型 2 管理程序的示例。
<img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_11_11_ekF92P.jpg" alt="Type 2 Hypervisor"></p>
</li>
</ol>
<h2 id="what-are-containers">What are Containers?</h2>
<blockquote>
<p>A container is a pkg of sw that includes all dependencies: code, runtime, config, &amp; system libraries so that it can run on any host system.
At runtime, the container is also granted its own isolated slice of OS resources like CPU, RAM, Disk, &amp; Networking.</p>
</blockquote>
<p>容器是包含所有依赖项的 sw 包：代码、运行时、配置和系统库，以便它可以在任何主机系统上运行。
在运行时，容器还被授予自己独立的操作系统资源片，如 CPU、RAM、磁盘和网络。
<img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_11_11_HPyYOB.jpg" alt="Application Container"></p>
<h2 id="why-do-you-need-containers">Why do you need Containers?</h2>
<blockquote>
<p>Containers are extremely useful in scaling DevOps efficiency across multiple codebases &amp; developer headcount. Containers ensures that containerized code works consistently on any machine the container is deployed to.</p>
</blockquote>
<p>容器在跨多个代码库和开发人员人数扩展 DevOps 效率方面非常有用。容器确保容器化代码在容器部署到的任何机器上一致地工作。</p>
<h2 id="how-does-a-container-work">How does a container work?</h2>
<blockquote>
<p>Containers virtualize a machines operating system at the user space level. Virtualizing user space leverages the existing mechanisms that divide system resources between separate user accounts and programs on an operating system.</p>
</blockquote>
<p>容器在用户空间级别虚拟化机器操作系统。虚拟化用户空间利用现有机制在操作系统上的单独用户帐户和程序之间划分系统资源。</p>
<blockquote>
<p>The Linux kernel has a few features that make this possible -&gt;
cgroups- It allow processes &amp; their resources to be grouped, isolated, &amp; managed as a unit.
Namespaces- limit what processes can see of the rest of the system.</p>
</blockquote>
<p>Linux 内核有一些特性使这成为可能 -&gt;
cgroups- 它允许将进程及其资源作为一个单元进行分组、隔离和管理。
命名空间 - 限制哪些进程可以看到系统的其余部分。
<img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_11_11_0Lnd1f.jpg" alt="cgroups">
<img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_11_11_2MqImg.jpg" alt="namespaces"></p>
<h2 id="benefits-of-containers">Benefits of containers</h2>
<ol>
<li><strong>Less overhead</strong> - Containers require less system resources than traditional or hardware virtual machine environments because they don’t include operating system images.
<strong>更少的开销</strong> - 容器比传统或硬件虚拟机环境需要更少的系统资源，因为它们不包含操作系统映像。</li>
<li><strong>Increased portability</strong> - Applications running in containers can be deployed easily to multiple different operating systems and hardware platforms.
<strong>增加便携性</strong> - 在容器中运行的应用程序可以轻松部署到多个不同的操作系统和硬件平台。</li>
<li><strong>More consistent operation</strong> - DevOps teams know applications in containers will run the same, regardless of where they are deployed.
<strong>更一致的操作</strong> - DevOps 团队知道容器中的应用程序将运行相同，无论它们部署在哪里。</li>
<li><strong>Greater efficiency</strong> - Containers allow applications to be more rapidly deployed, patched, or scaled.
<strong>更高的效率</strong> - 容器允许更快速地部署、修补或扩展应用程序。</li>
<li><strong>Better application development</strong> - Containers support agile and DevOps efforts to accelerate development, test, and production cycles
<strong>更好的应用开发</strong> —— 容器支持敏捷和 DevOps 工作，以加快开发、测试和生产周期。</li>
</ol>
<h2 id="container-use-cases">Container use cases</h2>
<ol>
<li><strong>Application Modernization</strong></li>
</ol>
<blockquote>
<p>Modernizing applications today means migrating programs from legacy on-premises deployments to cloud solutions. Bcoz containers are agile, they enhance an organization’s ability to migrate applications &amp; workflows seamlessly.</p>
</blockquote>
<p>今天的应用程序现代化意味着将程序从传统的本地部署迁移到云解决方案。 Bcoz 容器是敏捷的，它们增强了组织无缝迁移应用程序和工作流的能力。</p>
<ol start="2">
<li><strong>Refactor existing applications for containers</strong></li>
</ol>
<blockquote>
<p>Although refactoring is much more intensive than lift-and-shift migration, it enables the full benefits of a container environment.</p>
</blockquote>
<p>尽管重构比直接迁移要密集得多，但它可以充分发挥容器环境的优势。</p>
<ol start="3">
<li><strong>Deploying Microservices</strong></li>
</ol>
<blockquote>
<p>The microservices architecture allows sw developers to produce apps made up of several independent deployable services. Different components of d application hosted in containers are scalable &amp; amenable to updating w/o disrupting other services.</p>
</blockquote>
<p>微服务架构允许软件开发人员生成由几个独立的可部署服务组成的应用程序。托管在容器中的应用程序的不同组件是可扩展的，并且可以在不中断其他服务的情况下进行更新。</p>
<ol start="4">
<li><strong>Provide DevOps support for continuous integration and deployment (CI/CD)</strong></li>
</ol>
<blockquote>
<p>Container technology supports streamlined build, test, and deployment from the same container images.</p>
</blockquote>
<p>容器技术支持从相同的容器映像简化构建、测试和部署。</p>
<ol start="5">
<li><strong>Provide easier deployment of repetitive jobs and tasks</strong></li>
</ol>
<blockquote>
<p>Containers are being deployed to support one or more similar processes, which often run in the background, such as ETL functions or batch jobs.</p>
</blockquote>
<p>正在部署容器以支持一个或多个类似的流程，这些流程通常在后台运行，例如 ETL 功能或批处理作业。</p>
<h2 id="containers-vs-vms">Containers vs VMs</h2>
<blockquote>
<p>VM’s simulate d entire machine &amp; OS. Means VMs have simulated CPU/RAM/Filesystems/nw resources.
Containers only virtualize d user space of an existing OS. Therefore containers r much more lightweight den VMs. Containers can be utilized in an existing host OS.</p>
</blockquote>
<p>VM 模拟整个机器和操作系统。意味着 VM 具有模拟的 CPU/RAM/ 文件系统 /nw 资源。
容器仅虚拟化现有操作系统的用户空间。因此，容器是更轻量级的虚拟机。容器可以在现有的主机操作系统中使用。
<img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_11_11_lGsXiH.jpg" alt="Containers vs VMs"></p>
<h2 id="what-are-kubernetes-pods">What are (Kubernetes) Pods?</h2>
<blockquote>
<p>Pods are the smallest deployable units of computing that you can create &amp; manage in Kubernetes.
A Pod is a group of one or more containers, with shared storage &amp; nw  resources, &amp; a specification for how to run d  containers.</p>
</blockquote>
<p>Pod 是您可以在 Kubernetes 中创建和管理的最小的可部署计算单元。
Pod 是一组一个或多个容器，具有共享存储和网络资源，以及如何运行容器的规范。
<img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_11_11_xV5BPl.jpg" alt="Pods and Cluster"></p>
<h2 id="what-is-a-cluster">What is a cluster?</h2>
<blockquote>
<p>A cluster is a board that provides the circuitry to run all the pods (which have the container instances in them) in an orchestrated manner as defined by the users.
So there’s a symbiotic relationship between these terms:Container → Pod → Cluster</p>
</blockquote>
<p>集群是一块电路板，它提供了以用户定义的编排方式运行所有 pod（其中包含容器实例）的电路。
因此，这些术语之间存在共生关系：容器 → Pod → 集群
<img src="https://alphapenng-1305651397.cos.ap-shanghai.myqcloud.com/uPic/2021_11_11_pNpHed.jpg" alt="Container Pod Cluster"></p>
<ol>
<li>A container runs logically in a pod (though it also uses a container runtime).
容器在 pod 中逻辑运行（尽管它也使用容器运行时）。</li>
<li>A group of pods, related or unrelated, run on a cluster.
一组相关或不相关的 Pod 在集群上运行。</li>
<li>A cluster can contain many pods, related or unrelated [&amp;] grouped under d tight logical borders called namespaces.
一个集群可以包含许多 Pod，相关的或不相关的 [&amp;;] 在称为命名空间的紧密逻辑边界下分组。</li>
</ol>
]]></content:encoded></item></channel></rss>